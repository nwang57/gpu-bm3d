/**
 does block matching with cuda
**/
#include <cuda.h>
#include <cuda_runtime.h>
#include <device_launch_parameters.h>
#include <vector_types.h>
#include "params.h"
#include <assert.h>

// Index conversion
#define idx2(x,y,dim_x) ( (x) + ((y)*(dim_x)) )
#define min(x, y) ((x) < (y) ? (x) : (y))
#define max(x, y) ((x) > (y) ? (x) : (y))

// compute the distance between two image patches
__device__ int distance(
    const uchar* __restrict image,
    const uint2 p,
    const uint2 q,
    const uint dim,
    const uint image_w
)
{
    if (p.x == q.x && p.y == q.y) return 0;

    uint l2norm = 0;
    for (int y = 0; y < dim; ++y) {
        for (int x = 0; x < dim; ++x) {
            int diff = image[idx2(p.x+x,p.y+y,image_w)] - image[idx2(q.x+x,q.y+y,image_w)];
            l2norm += diff * diff;
        }
    }
    return l2norm;
}

/*
 * per thread block matching
 */
__global__ void block_matching(
	Q* g_stacks, 				//OUT: Size [num_ref * max_num_patches_in_stack]
	uint* g_num_patches_in_stack, //OUT: For each reference patch contains number of similar patches. Size [num_ref]
    uchar* input_image,          // IN: input image
    const uint distance_threshold
)
{
    uchar* image = input_image;
    uint2 image_dim;
    image_dim.x = cu_const_params.image_width;
    image_dim.y = cu_const_params.image_height;
    const uint patch_dim = cu_const_params.patch_size;
    const uint match_radius = cu_const_params.searching_window_size;
    const uint ref_stride = cu_const_params.stripe;
    const uint match_stride = 1; // make it one for now
    const uint max_num_patches_in_stack = cu_const_params.max_group_size;


    assert(image_dim.x >= patch_dim && image_dim.y >= patch_dim);
    // step 1: do pointer arithmetic to find out the position of this reference
    // tid is the id of reference patch
    uint tid = blockIdx.x * blockDim.x + threadIdx.x;
    if (tid >= cu_const_params.total_ref_patches) return;
    uint2 num_ref_patch = make_uint2(
        image_dim.x > patch_dim ?
        (image_dim.x - patch_dim) / ref_stride + 1 :
        1,
        image_dim.y > patch_dim ?
        (image_dim.y - patch_dim) / ref_stride + 1 :
        1
    );

    // find the x, y index of the reference patch
    uint ty = tid / num_ref_patch.x;
    if (ty >= num_ref_patch.y) return;
    uint tx = tid % num_ref_patch.x;

    // find the start position of the reference patch
    uint2 start_ref = make_uint2(tx * ref_stride, ty * ref_stride);

    // adjust edge case
    if (start_ref.x > image_dim.x - patch_dim)
        start_ref.x = image_dim.x - patch_dim;
    if (start_ref.y > image_dim.y - patch_dim)
        start_ref.y = image_dim.y - patch_dim;

    // step 2: match within the range
    uint2 start_q;
    start_q.x = start_ref.x > match_radius ? start_ref.x - match_radius : 0;
    start_q.y = start_ref.y > match_radius ? start_ref.y - match_radius : 0;

    Q* my_stack = g_stacks + tid * max_num_patches_in_stack;
    uint stack_count = 0;
    for (uint qy = start_q.y;
         qy <= image_dim.y - patch_dim && qy <= start_ref.y + match_radius;
         qy += match_stride) {
        for (uint qx = start_q.x;
            qx <= image_dim.x - patch_dim && qx <= start_ref.x + match_radius;
            qx += match_stride) {
            // calculate distance between q patch and ref patch
            uint2 q = make_uint2(qx,qy);
            int dist = distance(image, start_ref, q, patch_dim, image_dim.x);
            if (dist < distance_threshold) {
                if (stack_count < max_num_patches_in_stack) {
                        // still space in the stack, just add the patch in
                        my_stack[stack_count].distance = dist;
                        my_stack[stack_count].position = q;
                        ++stack_count;
                } else {
                    // find the largest distance in stack and compare.
                    int largest_dist = 0;
                    uint largest_dist_idx = 0;
                    for (uint i = 0; i < max_num_patches_in_stack; ++i) {
                        if (my_stack[i].distance > largest_dist) {
                            largest_dist = my_stack[i].distance;
                            largest_dist_idx = i;
                        }
                    }
                    // compare largest distance with new patch distance
                    if (dist < largest_dist) {
                        // replace the worst patch in stack with this new patch
                        my_stack[largest_dist_idx].distance = dist;
                        my_stack[largest_dist_idx].position = q;
                    }
                }
            }
        }
    }
    g_num_patches_in_stack[tid] = stack_count;
}


/*
 * per block a ref patch, each thread will search some pathces in the region.
 * and save to the shared memory. Then we perform the reduction on shared memory
 */
__global__ void block_matching2(
    Q* g_stacks,                //OUT: Size [num_ref * max_num_patches_in_stack]
    uint* g_num_patches_in_stack, //OUT: For each reference patch contains number of similar patches. Size [num_ref]
    uchar* input_image,          // IN: input image
    const uint distance_threshold
)
{
    uchar* image = input_image;
    uint2 image_dim;
    image_dim.x = cu_const_params.image_width;
    image_dim.y = cu_const_params.image_height;
    const uint patch_dim = cu_const_params.patch_size;
    const uint match_radius = cu_const_params.searching_window_size;
    const uint ref_stride = cu_const_params.stripe;
    // const uint match_stride = 1; // make it one for now
    const uint max_num_patches_in_stack = cu_const_params.max_group_size;
    const uint width = (image_dim.x - patch_dim) / ref_stride + 1;

    int bid = blockIdx.x;
    int ref_x = (bid % width) * ref_stride;
    int ref_y = (bid / width) * ref_stride;
    if (ref_x > image_dim.x - patch_dim)
        ref_x = image_dim.x - patch_dim;
    if (ref_y > image_dim.y - patch_dim)
        ref_y = image_dim.y - patch_dim;

    uint2 q;
    q.x = ref_x > match_radius ? ref_x - match_radius : 0;
    q.y = ref_y > match_radius ? ref_y - match_radius : 0;
    int end_x = min(image_dim.x - patch_dim, ref_x + match_radius);
    int end_y = min(image_dim.y - patch_dim, ref_y + match_radius);

    // each thread will find the most similar patch in the shared memory for reduction
    int q_width = (end_x - q.x);
    int q_height = (end_y - q.y);
    int size = q_width * q_height;
    int num_q_per_thread = max(1, size / blockDim.x);
    int tid = threadIdx.x;

    // extern __shared__ Q s_data[]; // to store the distance and the position
    // printf("bid %d creating share total ref: %d\n", bid, gridDim.x);
    // Q min_stack(0,0,0xFFFFFFFF);
    // for (uint i = tid * num_q_per_thread; i < min(size, (tid+1) * num_q_per_thread); i++) {
    //     int x = (i % q_width) + q.x;
    //     int y = (i / q_width) + q.y;
    //     int dist = distance(image, make_uint2(ref_x, ref_y), make_uint2(x, y), patch_dim, image_dim.x);
    //     if (dist < distance_threshold && dist < min_stack.distance) {
    //         min_stack.position = make_uint2(x, y);
    //         min_stack.distance = dist;
    //     }
    // }
    // s_data[tid] = min_stack;
    // __syncthreads();
    if (bid == 8452 && threadIdx.x == 0) {
        // printf("Tid: %d, x(%d), y(%d), dist(%d)\n", tid, min_stack.position.x, min_stack.position.y, min_stack.distance);
        printf("bid %d, ref_x %d, ref_y %d\n", bid, ref_x, ref_y);
        printf("total blocks %d\n", gridDim.x);
        printf("patches in a block %d\n", size);
    }
}
